# ABC 107
- 4問/100分でした。本番で解けなかったD問題について書きます。

# [Median of Medians](https://beta.atcoder.jp/contests/abc107/tasks/arc101_b)
- 典型: 中央値は二分探索
- 典型: 区間和の高速数え上げはBIT
- 典型: 以上/より小さいが問題になっていているときは二値(-1/+1, 0/1)に変換する

::: tip 問題
長さ$N$の数列の、$\frac{N(N+1)}{2}$個の連続部分列に対し、その列それぞれから中央値をとってきて、新しく作った数列の中央値を求める。(この問題における中央値の定義は問題参照)
:::
- 考察
::: warning 中央値の性質
数列の中に、値が$X$以上の要素が半数以上存在する。このような性質を満たす$X$のうち最大のものを中央値と呼ぶ。
:::

::: warning 性質から分かること
数列の中央値を$M$としたとき、数列の中に値が$X$以上の要素が半数以上存在するならば、$X\leq M$
:::

::: warning 部分列ひとつを考える
$\frac{N(N+1)}{2}$個の部分列のひとつに着目する。値が$X$以上の要素がこの中に半数以上存在する場合を`case1`, 半数以上存在しない場合を`case2`とする。<br>
この部分列の中央値を$M$とおく。性質から分かることより、`case1`では$X \leq M$、`case2`では$M<X$となる。
:::

::: warning 部分列を集める
各部分列の中央値を集め、数列$M_1, M_2, ... , M_\frac{N(N+1)}{2}$とする。この数列の中央値$M$を求めたい。<br>
部分列ひとつひとつを考えることにより、それぞれの$M_i$が`case1`, `case2`いずれなのか分かっているとする。<br>
すると、`case1`の個数と`case2`の個数をそれぞれ$C_1, C_2$と置くと、<br>
$C_1 < C_2$ならばこの中に`case1`すなわち$X \leq M_i$なる$M_i$が半数以上存在することはないので、 $X$は中央値になることはない。したがって、$M<X$<br>
$C_2 \leq C_1$ならばこの中に`case1`すなわち$X \leq M_i$なる$M_i$が半数以上存在するので、 $X$は中央値になりうる。したがって、$X \leq M$<br>
あとは$X$を動かして境界の値である$M$を求めればよい。
:::
- 実装
- $\frac{N(N+1)}{2}$個の区間それぞれに対して$O(1)$を行っても間に合わない→セグ木などのデータ構造を使うことを考える。
- 今回は、「値が$X$以上の要素が数列の中に半数以上存在するか？」という問いに答えたい→X以上かより小さいかで`+1`, `-1`として累積和が非負ならば半数以上存在する。(累積和なら前処理が効く、0以上かそうでないかという問題に帰着される)
- 区間和と、

::: tip BIT
整数列$a_1,a_2,a_3,...,a_n$に対して、以下のクエリを$O(\log N)$で実現するデータ構造<br>
1.$sum(i)$: $a_1+a_2+a_3+...+a_i$を求める<br>
2.$add(i,x)$: $a_i$に$x$を加える
:::

- **解説**
- $n$個の区間の和を管理する。
    - $O(N)$メモリ
- 変数の値の更新
    - $O(\log N)$時間: 高々$\log_2 N + 1$個の区間に足すので
- 和の計算(prefix: $a_1 + ... + a_i$)
    - $O(\log N)$時間: 高々$\log_2 N + 1$個の区間の和なので

- **実装** (0-indexed)
```cpp
struct BIT {
    long long n;
    vector<long long> dat;

    void initialize(long long n_input){
        n = n_input + 1;
        dat.resize(n+1);
        for(int i = 0; i<=n; i++) dat[i] = 0;
    }

    long long sum(long long i){
        long long s = 0;
        while(i >= 0){
            s += dat[i];
            i = (i & (i+1)) - 1;
        }
        return s;
    }

    void add(long long i, long long x){
        while(i <= n){
            dat[i] += x;
            i |= i+1;
        }
    }
};
```
- **解説**
- `initialize`: n_input+2個の要素を持つvectorを0初期化する
- `sum`: $a_0+a_1+...+a_i$を求める。
- `add`:

- `i&(i+1)`について
- whileは収束するか？→$&$演算は両方のビットが立っているときのみビットが立つので一般に$a \& b \leq a$が成り立つ。したがって、$(i \& (i+1)) -1< i$となりwhileは必ず収束する。
- どのように収束していくのか？→以下のようなコードを組んで実験
```cpp
int main(){
  std::ios::sync_with_stdio(false);
  std::cin.tie(0);

  ifstream in("input.txt");
  cin.rdbuf(in.rdbuf());

  int i;cin>>i;
  while(i >= 0){
      i = (i & (i+1)) - 1;
      cout<<i<<" "<<i+1<<endl;
  }
  return 0;
}
```

```
入力:
1026
出力:
1025 1026
1023 1024
-1 0

入力:
1025
出力:
1023 1024
-1 0

入力:
1024
出力:
1023 1024
-1 0

入力:
1023
出力:
-1 0

入力:
1022
出力:
1021 1022
1019 1020
1015 1016
1007 1008
991 992
959 960
895 896
767 768
511 512
-1 0

入力:
100000000
出力:
99999999 100000000
99999743 99999744
99991551 99991552
99975167 99975168
99942399 99942400
99876863 99876864
99614719 99614720
98566143 98566144
96468991 96468992
92274687 92274688
83886079 83886080
67108863 67108864
-1 0
```
- 終了する直前は`i+1`の値が$2^n$になっている。すなわち$(2^n -1) \& 2^n = 0$
- `i+1`の減り具合は`2->4->8->16`や`256->8192->16384`のように、$2^n$倍したものが引かれていく。つまり、計算量は$\log n$と分かる。


- dat[i]は何を指しているのか？が知りたい。そこを可視化したい。
- 参考: betrue12さんの[code](https://beta.atcoder.jp/contests/arc101/submissions/3077246) BITの実装
- 参考: hosさんの[解説](http://hos.ac/slides/20140319_bit.pdf)
--------
- どうやって高速に各区間の中央値を求めるか？
- BIT、転倒数、+1,-1
- 類題
- http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0606
- http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0617
- https://beta.atcoder.jp/contests/abc106/tasks/abc106_d BITで解ける(taskerさん情報)
- http://codeforces.com/contest/1005/problem/E2
- https://www.ioi-jp.org/joi/2017/2018-yo/2018-yo-t6.html Lth Kth Number

https://www65.atwiki.jp/kyopro-lib/pages/12.html BIT